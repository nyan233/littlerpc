package main

import (
	"flag"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	version = "0.1.0"
)

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-lrpc %v\n", version)
		return
	}
	protogen.Options{
		ParamFunc: flag.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO3
		plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_PROTO3

		for _, pbFile := range plugin.Files {
			if !pbFile.Generate {
				continue
			}
			generateProxyCode(plugin, pbFile)
			generateServerCode(plugin, pbFile)
		}
		return nil
	})
}

func generateServerCode(plugin *protogen.Plugin, file *protogen.File) {
	// 生成文件名：<service>_server.pb.go
	filename := file.GeneratedFilenamePrefix + "_server.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// 生成文件头部
	g.P("// Code generated by protoc-gen-go-lrpc. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("/*")
	g.P("   @Generator   : protoc-gen-go-lrpc")
	g.P("   @CreateTime  : ", time.Now().Format("2006-01-02 15:04:05.999999 -0700 MST"))
	g.P("   @Author      : NoAuthor")
	g.P("   @Comment     : code is auto generate do not edit")
	g.P("*/")
	g.P()

	// 生成导入语句
	g.P("import (")
	g.P(`	"github.com/nyan233/littlerpc/core/server"`)
	g.P(`	"github.com/nyan233/littlerpc/core/common/context"`)
	g.P(")")
	g.P()

	// 为每个服务生成代理代码
	for _, service := range file.Services {
		sTypeName := service.GoName + "Server"
		g.P(fmt.Sprintf("type %s struct {", sTypeName))
		g.P("    server.RpcServer")
		g.P("}")
		g.P()
		g.P(fmt.Sprintf("func (s *%s) Setup() {}", sTypeName))
		g.P()
		for _, method := range service.Methods {
			// 添加方法注释
			if method.Comments.Leading.String() != "" {
				g.P(formatComments(method.Comments.Leading.String()))
			}
			g.P(fmt.Sprintf("func (s *%s) RegisterHandler(ctx *context.Context, req *%s) (rsp *%s, err error) {", sTypeName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
			g.P("    panic(\"not implemented\")")
			g.P("}")
			g.P()
		}
	}
}

func generateProxyCode(plugin *protogen.Plugin, file *protogen.File) {
	// 生成文件名：<service>_proxy.pb.go
	filename := file.GeneratedFilenamePrefix + "_proxy.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// 生成文件头部
	g.P("// Code generated by protoc-gen-go-lrpc. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("/*")
	g.P("   @Generator   : protoc-gen-go-lrpc")
	g.P("   @CreateTime  : ", time.Now().Format("2006-01-02 15:04:05.999999 -0700 MST"))
	g.P("   @Author      : NoAuthor")
	g.P("   @Comment     : code is auto generate do not edit")
	g.P("*/")
	g.P()

	// 生成导入语句
	g.P("import (")
	g.P(`	"github.com/nyan233/littlerpc/core/client"`)
	g.P(`	"github.com/nyan233/littlerpc/core/common/context"`)
	g.P(")")
	g.P()

	// 生成 UUID 用于 caller 接口
	uuidStr := strings.ReplaceAll(uuid.New().String(), "-", "")

	// 生成类型检查
	g.P("var (")
	g.P("	_ caller", uuidStr, " = new(client.Client)")
	for _, service := range file.Services {
		implStruct := strings.ToLower(service.GoName[:1]) + service.GoName[1:] + "Impl"
		g.P("	_ ", service.GoName, "Proxy = new(", implStruct, ")")
	}
	g.P(")")
	g.P()

	// 生成 caller 接口
	g.P("type caller", uuidStr, " interface {")
	g.P("	Request2(service string, opts []client.CallOption, reqCount int, args ...interface{}) error")
	g.P("}")
	g.P()

	// 为每个服务生成代理代码
	for _, service := range file.Services {
		proxyInterface := service.GoName + "Proxy"
		implStruct := strings.ToLower(service.GoName[:1]) + service.GoName[1:] + "Impl"

		// 生成代理接口
		g.P("type ", proxyInterface, " interface {")
		for _, method := range service.Methods {
			g.P(generateMethodSignature(method))
		}
		g.P("}")
		g.P()

		// 生成实现结构体
		g.P("type ", implStruct, " struct {")
		g.P("	caller", uuidStr)
		g.P("}")
		g.P()

		// 生成构造函数
		g.P("func New", service.GoName, "(b caller", uuidStr, ") ", proxyInterface, " {")
		g.P("	proxy := new(", implStruct, ")")
		g.P("	c, ok := b.(caller", uuidStr, ")")
		g.P(`	if !ok {`)
		g.P(`		panic("the argument is not implemented caller")`)
		g.P("	}")
		g.P("	proxy.caller", uuidStr, " = c")
		g.P("	return proxy")
		g.P("}")
		g.P()

		// 生成方法实现
		for _, method := range service.Methods {
			// 添加方法注释
			if method.Comments.Leading.String() != "" {
				g.P(formatComments(method.Comments.Leading.String()))
			}
			g.P(generateMethodImpl(method, service.GoName, implStruct))
		}
	}
}

func generateMethodSignature(method *protogen.Method) string {
	// 输入参数：ctx 和 req
	args := []string{
		"a0 *context.Context",
		fmt.Sprintf("a1 *%s", method.Input.GoIdent.GoName),
		"opts ...client.CallOption",
	}

	// 输出参数：rsp 和 error
	returns := []string{
		fmt.Sprintf("r0 *%s", method.Output.GoIdent.GoName),
		"r1 error",
	}

	return fmt.Sprintf("\t%s(%s) (%s)", method.GoName, strings.Join(args, ", "), strings.Join(returns, ", "))
}

func generateMethodImpl(method *protogen.Method, serviceName, implStruct string) string {
	// 输入参数
	args := []string{
		"a0",
		fmt.Sprintf("a1 *%s", method.Input.GoIdent.GoName),
		"opts ...client.CallOption",
	}

	// 输出参数
	returns := []string{
		fmt.Sprintf("r0 *%s", method.Output.GoIdent.GoName),
		"r1 error",
	}

	// 方法体
	body := []string{
		fmt.Sprintf("r0 = new(%s)", stripPackage(method.Output.GoIdent.GoName)),
		fmt.Sprintf(`r1 = p.Request2("%s.%s", opts, 2, a0, a1, r0)`, serviceName, method.GoName),
		"return",
	}

	return fmt.Sprintf("func (p %s) %s(%s) (%s) {\n\t%s\n}\n", implStruct, method.GoName, strings.Join(args, ", "), strings.Join(returns, ", "), strings.Join(body, "\n\t"))
}

func formatComments(comment string) string {
	// 将 proto 文件中的注释格式化为 Go 文档注释
	lines := strings.Split(strings.TrimSpace(comment), "\n")
	var formatted []string
	for _, line := range lines {
		// 移除 proto 注释的前导 // 或 /* */，并添加 Go 文档注释前缀
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "//") {
			line = strings.TrimPrefix(line, "//")
			line = strings.TrimSpace(line)
		}
		if line != "" {
			formatted = append(formatted, "// "+line)
		}
	}
	return strings.Join(formatted, "\n")
}

func stripPackage(typeName string) string {
	parts := strings.Split(typeName, ".")
	return parts[len(parts)-1]
}
